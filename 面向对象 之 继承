1、原型链继承
缺点：继承的方法 属性都共享了
```
 function SuperType(){
            this.property = true;
        }
        
        SuperType.prototype.getSuperValue = function(){
            return this.property;
        };
        
        function SubType(){
            this.subproperty = false;
        }
        
        //  继 承 SuperType； 继承了 所有 属性方法，这些属性方法变成了原型属性了（即共享）
        SubType.prototype = new SuperType();
        
        //  给 原型添加方法 要放在 继承 后面； 并且不要用字面量创建
        SubType.prototype.getSubValue = function (){
            return this.subproperty;
        };
}
```

2、借用构造函数

```
function SuperType(){
    this.colors = ["red", "blue", "green"];
}
function SubType(){  
  //使用 call 在构造函数里面 继承；获得 构造函数 里面的东西；无法继承 原型 里面的东西
  //这不就是在里面调用父函数吗。。。只是改变了this而已
  SuperType.call(this);
}

var instance1 = new SubType();

```

3、 原型与构造函数结合起来使用
SuperType.call(this, name); 解决了无法传参数的问题，并且构造函数里面的东西都是独立的
SubType.prototype = new SuperType();传递了方法，使得方法共享，而构造函数里面的参数传进来会被上面那个覆盖了，不会共享
```
function SuperType(name){
    this.name = name;
    this.colors = ["red", "blue", "green"];
}

SuperType.prototype.sayName = function(){
    alert(this.name);
};

function SubType(name, age){  
    SuperType.call(this, name); 
    
    this.age = age;
}

SubType.prototype = new SuperType();

SubType.prototype.sayAge = function(){
    alert(this.age);
};

var instance1 = new SubType("Nicholas", 29);
instance1.colors.push("black");
alert(instance1.colors);  //"red,blue,green,black"
instance1.sayName();      //"Nicholas";
instance1.sayAge();       //29
```
